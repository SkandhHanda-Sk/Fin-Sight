import re
import json
from collections import defaultdict
from thefuzz import process

INCOME_STATEMENT_ALIASES = {
    'total_net_sales': ['Total net sales', 'Revenues', 'Net sales'],
    'gross_margin': ['Gross margin', 'Gross profit'],
    'operating_income': ['Operating income', 'Income from operations'],
    'net_income': ['Net income', 'Net earnings'],
}

BALANCE_SHEET_ALIASES = {
    'cash_and_cash_equivalents': ['Cash and cash equivalents'],
    'total_current_assets': ['Total current assets'],
    'total_assets': ['Total assets'],
    'total_current_liabilities': ['Total current liabilities'],
    'total_liabilities': ['Total liabilities'],
    'total_shareholders_equity': ["Total shareholders’ equity", "Total equity"],
}

CASH_FLOW_ALIASES = {
    'net_income': ['Net income'],
    'cash_from_operating': ['Cash generated by operating activities'],
    'cash_from_investing': ['Cash used in investing activities'],
    'cash_from_financing': ['Cash used in financing activities'],
    'cash_at_end_of_period': ['Cash, cash equivalents and restricted cash, ending balances'],
}

class FinancialStatementParser:
    def __init__(self, text):
        self.text = text
        self.multiplier = self._get_multiplier()
        self.parsed_data = defaultdict(dict)

    def _get_multiplier(self):
        if 'in millions' in self.text.lower(): return 1_000_000
        if 'in thousands' in self.text.lower(): return 1_000
        return 1

    def _clean_and_convert_value(self, value_str):
        if not isinstance(value_str, str): return None
        value_str = value_str.strip()
        is_negative = value_str.startswith('(') and value_str.endswith(')')
        if is_negative: value_str = value_str[1:-1]
        value_str = value_str.replace(',', '').replace('$', '')
        try: number = float(value_str)
        except (ValueError, TypeError): return None
        return -number if is_negative else number

    def _extract_values_from_line(self, line, num_columns):
        values = re.findall(r'(\(?\s*\$?\s*[\d,]+\s*\)?)', line)
        if len(values) < num_columns: return None
        return [self._clean_and_convert_value(v) for v in values[-num_columns:]]

    def _find_canonical_metric(self, line, aliases_dict, score_cutoff=90):
        line_text_match = re.match(r'([A-Za-z,\s\(\)/]+[A-Za-z\)])', line)
        if not line_text_match: return None
        line_text = line_text_match.group(1).strip().lower()
        best_match_key, highest_score = None, 0
        for key, aliases in aliases_dict.items():
            match, score = process.extractOne(line_text, [a.lower() for a in aliases])
            if score > highest_score:
                highest_score, best_match_key = score, key
        return best_match_key if highest_score >= score_cutoff else None

    def _parse_header(self, header_text):
        years = re.findall(r'\b(\d{4})\b', header_text)
        num_columns = len(years)
        if num_columns == 0: return []
        period_map = {'three months ended': 'quarter', 'twelve months ended': 'annual'}
        found_periods = [{'type': period_map[k], 'pos': m.start()} 
                         for k, t in period_map.items() 
                         for m in re.finditer(k, header_text.lower())]
        found_periods.sort(key=lambda x: x['pos'])
        column_keys = []
        if not found_periods:
            column_keys = [f"{y}_snapshot" for y in years]
        elif len(found_periods) == 1:
            period_type = found_periods[0]['type']
            column_keys = [f"{y}_{period_type}" for y in years]
        else:
            num_cols_per_period = num_columns // len(found_periods)
            for i, period in enumerate(found_periods):
                start_index = i * num_cols_per_period
                end_index = start_index + num_cols_per_period
                column_keys += [f"{y}_{period['type']}" for y in years[start_index:end_index]]
        return column_keys

    def _split_header_and_body(self, text, first_data_row_keywords):
        for keyword in first_data_row_keywords:
            match = re.search(keyword, text, re.IGNORECASE)
            if match:
                return text[:match.start()], text[match.start():]
        return "", text

    def _parse_generic_statement_body(self, body_text, aliases, column_keys):
        for line in body_text.split('\n'):
            canonical_key = self._find_canonical_metric(line, aliases)
            if canonical_key:
                values = self._extract_values_from_line(line, len(column_keys))
                if values:
                    for i, col_key in enumerate(column_keys):
                        if canonical_key not in self.parsed_data[col_key]:
                            self.parsed_data[col_key][canonical_key] = values[i]

    def _validate(self):
        print("\n--- Running Data Validation ---")
        for period, data in self.parsed_data.items():
            year = period.split('_')[0]
            if all(k in data for k in ['total_assets', 'total_liabilities', 'total_shareholders_equity']):
                assets, liabilities, equity = data['total_assets'], data['total_liabilities'], data['total_shareholders_equity']
                if abs(assets - (liabilities + equity)) > 1.0:
                    print(f"⚠️  WARNING for {period}: Balance sheet does not balance! Diff: {assets - (liabilities + equity):,.0f}")
                else:
                    print(f"✅ SUCCESS for {year}: Balance sheet equation balances.")
        print("--- Validation Finished ---\n")

    def parse(self):
        op_stmt_text_match = re.search(r'STATEMENTS\s+OF\s+OPERATIONS.*?(?=BALANCE\s+SHEETS)', self.text, re.DOTALL | re.IGNORECASE)
        balance_sheet_text_match = re.search(r'BALANCE\s+SHEETS.*?(?=STATEMENTS\s+OF\s+CASH\s+FLOWS)', self.text, re.DOTALL | re.IGNORECASE)
        cash_flow_text_match = re.search(r'STATEMENTS\s+OF\s+CASH\s+FLOWS.*', self.text, re.DOTALL | re.IGNORECASE)

        statements_to_parse = {
            "Income Statement": (op_stmt_text_match, INCOME_STATEMENT_ALIASES, ['Net sales:']),
            "Balance Sheet": (balance_sheet_text_match, BALANCE_SHEET_ALIASES, ['Current assets:']),
            "Cash Flow": (cash_flow_text_match, CASH_FLOW_ALIASES, ['Operating activities:']),
        }

        for name, (match_obj, aliases, keywords) in statements_to_parse.items():
            if not match_obj:
                print(f"⚠️ WARNING: Could not find {name} in the text.")
                continue
            text = match_obj.group(0)
            header_text, body_text = self._split_header_and_body(text, keywords)
            column_keys = self._parse_header(header_text)
            if not column_keys:
                print(f"⚠️ WARNING: Could not determine columns for {name}. Skipping.")
                continue
            self._parse_generic_statement_body(body_text, aliases, column_keys)

        final_results = []
        for key, data in sorted(self.parsed_data.items()):
            year, period_type = key.split('_')
            scaled_data = {k: v * self.multiplier for k, v in data.items()}
            period_data = {'year': int(year), 'period_type': period_type, **scaled_data}
            final_results.append(period_data)

        self._validate()
        return final_results
# --- At the end of your parser.py script ---

if __name__ == '__main__':
    input_file_path = 'output/financial_report_extracted.txt'
    output_json_path = 'output/parsed_financials.json' # Define output path

    print(f"--- 'Play Safe' Parser Test ---")
    print(f"Parsing only high-confidence 'Golden Metrics' from: {input_file_path}\n")

    try:
        with open(input_file_path, 'r', encoding='utf-8') as f:
            file_content = f.read()

        parser = FinancialStatementParser(file_content)
        parsed_data = parser.parse()

        # --- SAVE THE RESULTS ---
        with open(output_json_path, 'w', encoding='utf-8') as f:
            json.dump(parsed_data, f, indent=4)
        
        print(f"✅ Parsing Successful! Clean data saved to: {output_json_path}")
        # You can still print it to the console if you want
        # print("Extracted and Corrected Data (JSON format):")
        # print(json.dumps(parsed_data, indent=4))

    except FileNotFoundError:
        print(f"❌ ERROR: The file was not found at '{input_file_path}'.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

    print("\n--- Parser Test Finished ---")